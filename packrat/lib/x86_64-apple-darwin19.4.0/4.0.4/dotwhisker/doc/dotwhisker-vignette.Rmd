---
title: "dotwhisker: Dot-and-Whisker Plots of Regression Results"
author: "Frederick Solt and Yue Hu"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
bibliography: vignette.bib
vignette: >
  %\VignetteIndexEntry{dotwhisker: Dot-and-Whisker Plots of Regression Results}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  message = FALSE,
  warning = FALSE,
  dpi = 300
)

library(broomExtra)
library(margins)
```


Graphs have long been known to be a more compact and effective means of conveying the results of regression models than tables [@Gelman2002; @Kastellec2007], but many researchers continue to list these results in tables. The reason, @Kastellec2007 surmised, is "simply put, it takes much greater effort to produce a quality graph than a table." The `dotwhisker` package provides a quick and easy way to create highly customizable dot-and-whisker plots for presenting and comparing the output of regression models. It can be used to plot estimates of coefficients or other quantities of interest (e.g., predicted probabilities) within a single model or across different models: the estimates are presented as dots and their confidence intervals as whiskers [see @Kastellec2007, 765-767].

Users can easily customize the content of their plots: presenting multiple models or results for a subset of variables is easy. Moreover, by outputting `ggplot` objects [@Wickham2009], `dotwhisker` allows users to further modify the format of their plots in nearly infinite ways.

This vignette illustrates basic use of the package's mainstay function, `dwplot`, for creating dot-and-whisker plots from model objects; more advanced uses of `dwplot` that employ tidy data frames as input; and, finally, some useful variations of dot-and-whisker plots that are easily made using other functions in the `dotwhisker` package.

# Basic Use: Plotting Results from One or More Regression Models

Generating dot-and-whisker plots from model objects generated by the most commonly used regression functions is straightforward.  To make a basic dot-and-whisker plot of any single model object of a class supported by [`broomExtra::tidy_parameters`](https://indrajeetpatil.github.io/broomExtra/), simply pass it to `dwplot`.  For these examples, we'll use the `mtcars` dataset extracted from the 1974 volume of the US magazine, _Motor Trend_.

```{r basic, out.width="100%"}
#Package preload
library(dotwhisker)
library(dplyr)

# run a regression compatible with tidy
m1 <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars)

# draw a dot-and-whisker plot
dwplot(m1)
```

By default, the whiskers span the 95% confidence interval.  To change the width of the confidence interval, specify a `ci` argument to pass to `broomExtra::tidy_parameters()`:

```{r ci, out.width="100%"}
dwplot(m1, ci = .99)  # using 99% CI
```

Plotting the results of more than one regression model is just as easy.  Just pass the model objects to `dwplot` as a list.  The `dodge_size` argument is used to adjust the space between the estimates of one variable when multiple models are presented in a single plot.  Its default value of .4 will usually be fine, but, depending on the dimensions of the desired plot, more pleasing results may be achieved by setting `dodge_size` to lower values when the plotted results include a relatively small number of predictors or to higher values when many models appear on the same plot.

```{r multipleModels, out.width="100%"}
m2 <- update(m1, . ~ . + hp) # add another predictor
m3 <- update(m2, . ~ . + am) # and another 

dwplot(list(m1, m2, m3))
```

Model intercepts are rarely theoretically interesting [see @Kastellec2007, 765], so they are excluded by `dwplot` by default.  They are easy to include if desired, however, by setting the `show_intercept` argument to true.

```{r intercept, out.width="100%"}
dwplot(list(m1, m2, m3), show_intercept = TRUE)
```

Moreover, the output of `dwplot` is a `ggplot` object. Add or change any `ggplot` layers after calling `dwplot` to achieve the desired presentation.

```{r ggplot, fig.width=4}
dwplot(list(m1, m2, m3),
       vline = geom_vline(xintercept = 0, colour = "grey60", linetype = 2)) %>% # plot line at zero _behind_ coefs
    relabel_predictors(c(wt = "Weight",                       
                         cyl = "Cylinders", 
                         disp = "Displacement", 
                         hp = "Horsepower", 
                         gear = "Gears", 
                         am = "Manual")) +
     theme_bw() + xlab("Coefficient Estimate") + ylab("") +
     geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
     ggtitle("Predicting Gas Mileage") +
     theme(plot.title = element_text(face="bold"),
           legend.position = c(0.007, 0.01),
           legend.justification = c(0, 0), 
           legend.background = element_rect(colour="grey80"),
           legend.title = element_blank()) 
```

Note that providing a named character vector to `relabel_predictors`, a `dotwhisker` function, conveniently renames the predictors.

There are many other packages (e.g., `coefplot`) that have the ability to draw dot-and-whisker plots of at least a single set of regression results taking model objects as input. While this is very convenient, it also comes with some severe limitations.  First, many less common model objects are not supported. Second, rescaling coefficients, reordering them, or just plotting a subset of results is typically impossible.  And third, quantities of interest beyond coefficient estimates cannot be plotted.  The `dotwhisker` package avoids all of these limitations by optionally taking as its input a tidy data frame of estimates drawn from a model object rather than the model object itself.

# Advanced Use: Decoration and Modification

## Plotting Results Stored in a Tidy Data Frame 

In addition to model objects, the input for `dwplot` may be a tidy data frame that includes three columns: `term`, that is, the variable name; `estimate`, the regression coefficients or other quantity of interest; and `std.error`, the standard errors associated with these estimates. In place of `std.error` one may substitute `conf.low`, the lower bounds of the confidence intervals of the estimates, and `conf.high`, the corresponding upper bounds. As noted above, `broom::tidy` [@Robinson2015] produces such a data frame of estimates for many common classes of model objects (indeed, `dwplot` was written to expect a data.frame with the columns `term`, `estimate`, and `std.error` because this is the format of the output produced by `tidy`). When more than one model's results are to be plotted, an additional column `model` that identifies the two models must be added to the data frame (alternate names for this last column may be specified by using the `model_name` argument). 

```{r tidyData, out.width="100%"}
# regression compatible with tidy
m1_df <- tidy(m1) # create data.frame of regression results
m1_df # a tidy data.frame available for dwplot
dwplot(m1_df) #same as dwplot(m1)
```

Using `tidy` can be helpful when one wishes to omit certain model estimates from the plot.  To illustrate, we drop the intercept (although this is in fact done by `dwplot` automatically by default):

```{r tidy, out.width="100%"}
m1_df <- tidy(m1) %>% filter(term != "(Intercept)") %>% mutate(model = "Model 1")
m2_df <- tidy(m2) %>% filter(term != "(Intercept)") %>% mutate(model = "Model 2")

two_models <- rbind(m1_df, m2_df)

dwplot(two_models)
```

You can also filter by regular expressions. This can be helpful, for instance, if a model contains a factor with many levels (e.g., a dummy variable for each country) which you might not want to include in your plot.

```{r regularExpression, out.width="100%"}
# Transform cyl to factor variable in the data
m_factor <- lm(mpg ~ wt + cyl + disp + gear, data = mtcars %>% mutate(cyl = factor(cyl)))

# Remove all model estimates that start with cyl*
m_factor_df <- tidy(m_factor) %>% 
  filter(!grepl('cyl*', term))

dwplot(m_factor_df)
```

It can also be convenient to build a tidy data frame of regression results directly, that is, without first creating model objects:

```{r relabel, fig.width=4}
# Run model on subsets of data, save results as tidy df, make a model variable, and relabel predictors
by_trans <- mtcars %>% 
    group_by(am) %>%                                         # group data by trans
    do(tidy(lm(mpg ~ wt + cyl + disp + gear, data = .))) %>% # run model on each grp
    rename(model=am) %>%                                     # make model variable
    relabel_predictors(c(wt = "Weight",                      # relabel predictors
                     cyl = "Cylinders",          
                     disp = "Displacement",
                     gear = "Gear"))

by_trans

dwplot(by_trans, 
       vline = geom_vline(xintercept = 0, colour = "grey60", linetype = 2)) + # plot line at zero _behind_ coefs
    theme_bw() + xlab("Coefficient Estimate") + ylab("") +
    ggtitle("Predicting Gas Mileage by Transmission Type") +
    theme(plot.title = element_text(face="bold"),
          legend.position = c(0.007, 0.01),
          legend.justification = c(0, 0),
          legend.background = element_rect(colour="grey80"),
          legend.title.align = .5) +
    scale_colour_grey(start = .3, end = .7,
                      name = "Transmission",
                      breaks = c(0, 1),
                      labels = c("Automatic", "Manual"))
```

Also note in the above example the additional manner of using the `relabel_predictors` function: in addition to being used on the `ggplot` object created by `dwplot` before further customization, it may also be used on a tidy data frame before it is passed to `dwplot`.

Additionally, one can change the shape of the point estimate instead of using different colors. This can be useful, for example, when a plot needs to be printed in black and white.  Here we also vary the linetype of the whiskers.

```{r custom, fig.width=4}
dwplot(by_trans,
       vline = geom_vline(xintercept = 0, colour = "grey60", linetype = 2), # plot line at zero _behind_ coefs
       dot_args = list(aes(shape = model)),
       whisker_args = list(aes(linetype = model))) +
    theme_bw() + xlab("Coefficient Estimate") + ylab("") +
    ggtitle("Predicting Gas Mileage by Transmission Type") +
    theme(plot.title = element_text(face="bold"),
          legend.position = c(0.007, 0.01),
          legend.justification = c(0, 0),
          legend.background = element_rect(colour="grey80"),
          legend.title.align = .5) +
    scale_colour_grey(start = .1, end = .1, # if start and end same value, use same colour for all models 
                      name = "Model", 
                      breaks = c(0, 1),
                      labels = c("Automatic", "Manual")) +
    scale_shape_discrete(name = "Model",
                         breaks = c(0, 1),
                         labels = c("Automatic", "Manual"))
```

It is also easy to plot classes of model objects that are not supported by `tidy`: one simply extracts the results from the model object and builds the data frame to pass to `dwplot` oneself.  Many functions generate results that can be extracted by `coef()`.

```{r clm, out.width="100%"}
# the ordinal regression model is not supported by tidy
m4 <- ordinal::clm(factor(gear) ~ wt + cyl + disp, data = mtcars)
m4_df <- coef(summary(m4)) %>% 
  data.frame() %>% 
  tibble::rownames_to_column("term") %>%
  rename(estimate = Estimate, std.error = Std..Error)
m4_df
dwplot(m4_df)
```

Working with a tidy data frame, it is similarly straightforward to plot just a subset of results or to rescale or reorder coefficients. One often desirable manipulation is to standardize the scales of variables. @Gelman2008, for example, suggests rescaling ordinal and continuous predictors by two standard deviations to facilitate comparison with dichotomous predictors. Although this can of course be done before model estimation, it can be more convenient to simply rescale the coefficients afterwards; the `by_2sd` function, which takes as arguments a data frame of estimates along with the original data frame upon which the model was based, automates this calculation.

```{r by2sd, out.width="100%"}
# Customize the input data frame
m1_df_mod <- m1_df %>%                 # the original tidy data.frame
    by_2sd(mtcars) %>%                 # rescale the coefficients
    arrange(term)                      # alphabetize the variables

m1_df_mod  # rescaled, with variables reordered alphabetically
dwplot(m1_df_mod)
```

An input data frame can also be constructed from estimates of other quantities of interest, such as margins, odds ratios, or predicted probabilities, rather than coefficients. 

```{r margins, out.width="100%"}
# Create a data.frame of marginal effects
m5 <- glm(am ~ wt + cyl + mpg, data = mtcars, family = binomial)
m5_margin <- margins::margins(m5) %>%
  summary() %>%
  dplyr::rename(
    term = factor,
    estimate = AME,
    std.error = SE,
    conf.low = lower,
    conf.high = upper,
    statistic = z,
    p.value = p
  )
m5_margin

dwplot(m5_margin)
```

Since the marginal effects are widely used in nowadays social science, `dwplot` offers a convenient shortcut `margins`.
Users can plot the average marginal effects (AME) instead of regression coefficients by setting `margins` to TRUE. 
The confidence intervals of the AME can be set by the argument `ci`.

```{r marginsShort, out.width="100%"}
dwplot(m5, margins = TRUE)
dwplot(m5, margins = TRUE, ci = .8)
```



## Grouping Predictors 
It is frequently desirable to convey that the predictors in a model depicted in a dot-and-whisker plot form groups of some sort.  This can be achieved by passing the finalized plot to the `add_brackets` function. To pass the finalized plot to `add_brackets` without creating an intermediate object, simply wrap the code that generates it in braces (`{` and `}`): 

```{r brackets, fig.width=4.5}
# Create list of brackets (label, topmost included predictor, bottommost included predictor)
three_brackets <- list(c("Overall", "Weight", "Weight"), 
                       c("Engine", "Cylinders", "Horsepower"),
                       c("Transmission", "Gears", "Manual"))

{dwplot(list(m1, m2, m3), 
        vline = geom_vline(xintercept = 0, colour = "grey60", linetype = 2)) %>% # plot line at zero _behind_ coefs
    relabel_predictors(c(wt = "Weight",                       # relabel predictors
                         cyl = "Cylinders",
                         disp = "Displacement", 
                         hp = "Horsepower", 
                         gear = "Gears", 
                         am = "Manual")) +
    theme_bw() + xlab("Coefficient Estimate") + ylab("") +
    ggtitle("Predicting Gas Mileage") +
    theme(plot.title = element_text(face="bold"),
          legend.position = c(0.993, 0.99),
          legend.justification=c(1, 1),
          legend.background = element_rect(colour="grey80"),
          legend.title = element_blank())} %>% 
    add_brackets(three_brackets)
```

## Presenting Regression Results as Normal Distributions

[Inspired by](https://twitter.com/BenJamesEdwards/status/979751070254747650) the way @Edwards2016 [p.5] displayed regression coefficients as normal distributions, `dotwhisker` now provides an easy way to make similar plots.  To create such plots, call `dwplot` as always but include the argument `style = "distribution"`, then customize with other `dotwhisker` functions and `ggplot` additions as usual:

```{r distribution, fig.height=5, fig.width=5}

by_transmission_brackets <- list(c("Overall", "Weight", "Weight"), 
                       c("Engine", "Cylinders", "Horsepower"),
                       c("Transmission", "Gears", "Gears"))
        
{mtcars %>%
    split(.$am) %>%
    purrr::map(~ lm(mpg ~ wt + cyl + gear + qsec, data = .x)) %>%
    dwplot(style = "distribution") %>%
    relabel_predictors(wt = "Weight",
                         cyl = "Cylinders",
                         disp = "Displacement",
                         hp = "Horsepower",
                         gear = "Gears") +
    theme_bw() + xlab("Coefficient") + ylab("") +
    geom_vline(xintercept = 0, colour = "grey60", linetype = 2) +
    theme(legend.position = c(.995, .99),
          legend.justification = c(1, 1),
          legend.background = element_rect(colour="grey80"),
          legend.title.align = .5) +
    scale_colour_grey(start = .8, end = .4,
                      name = "Transmission",
                      breaks = c("Model 0", "Model 1"),
                      labels = c("Automatic", "Manual")) +
    scale_fill_grey(start = .8, end = .4,
                    name = "Transmission",
                    breaks = c("Model 0", "Model 1"),
                    labels = c("Automatic", "Manual"))} %>%
    add_brackets(by_transmission_brackets) +
    ggtitle("Predicting Gas Mileage by Transmission Type") +
    theme(plot.title = element_text(face = "bold", hjust = 0.5))

```

## The 'Secret Weapon' and 'Small Multiple' Plots 
A variation of dot-and-whisker plot is used to compare the estimated coefficients for a single predictor across many models or datasets: Andrew Gelman calls such plots [the 'secret weapon'](https://statmodeling.stat.columbia.edu/2005/03/07/the_secret_weap/).  They are easy to make with the `secret_weapon` function.  Like `dwplot`, the function accepts both lists of model objects and tidy data frames as input. The `var` argument is used to specify the predictor for which results are to be plotted.

```{r secretWeapon, fig.width=5}
data(diamonds)

# Estimate models for many subsets of data, put results in a tidy data.frame
by_clarity <- diamonds %>% 
    group_by(clarity) %>%
    do(tidy(lm(price ~ carat + cut + color, data = .), conf.int = .99)) %>%
    ungroup %>% rename(model = clarity)

# Deploy the secret weapon
secret_weapon(by_clarity, var = "carat") + 
    xlab("Estimated Coefficient (Dollars)") + ylab("Diamond Clarity") +
    ggtitle("Estimated Coefficients for Diamond Size Across Clarity Grades") +
    theme(plot.title = element_text(face="bold"))
```

A final means of presenting many models' results at once in a particularly compact format is the "small multiple" plot of regression results [see @Kastellec2007, 766]. Small-multiple plots present estimates in multiple panels, one for each variable: they are similar to a stack of secret weapon plots.  The `small_multiple` function makes generating these plots simple.  Here, we pass a tidy data frame of six models to the function so we can to rescale the coefficients first, but the function can accept a list of model objects as well.

```{r smallMultiple, fig.height=7}
# Generate a tidy data frame of regression results from six models
m <- list()
ordered_vars <- c("wt", "cyl", "disp", "hp", "gear", "am")
m[[1]] <- lm(mpg ~ wt, data = mtcars) 
m123456_df <- m[[1]] %>% 
    tidy() %>%
    by_2sd(mtcars) %>%
    mutate(model = "Model 1")
for (i in 2:6) {
    m[[i]] <- update(m[[i-1]], paste(". ~ . +", ordered_vars[i]))
    m123456_df <- rbind(m123456_df, m[[i]] %>%
                            tidy() %>%
                            by_2sd(mtcars) %>%
                            mutate(model = paste("Model", i)))
}

# Relabel predictors (they will appear as facet labels)
m123456_df <- m123456_df %>% 
  relabel_predictors(c("(Intercept)" = "Intercept",
                     wt = "Weight",
                     cyl = "Cylinders",
                     disp = "Displacement",
                     hp = "Horsepower",
                     gear = "Gears",
                     am = "Manual"))
 
# Generate a 'small multiple' plot
small_multiple(m123456_df) +
  theme_bw() + ylab("Coefficient Estimate") +
  geom_hline(yintercept = 0, colour = "grey60", linetype = 2) +
  ggtitle("Predicting Mileage") +
  theme(plot.title = element_text(face = "bold"), 
        legend.position = "none",
        axis.text.x = element_text(angle = 60, hjust = 1)) 
```

To facilitate comparisons across, e.g., results generated across different samples, one can cluster the results presented in a small multiple plot.  To do so, results that should be clustered should have the same value of `model`, but should be assigned different values of an additional `submodel` variable included in the tidy data frame passed to `small_multiple`. (We also replicate three examples in @Kastellec2007 with `dotwhisker` in a separate vignette, "kl2007_examples".)

```{r smallMultiple2, fig.width=4, fig.height=6}
# Generate a tidy data frame of regression results from five models on
# the mtcars data subset by transmission type
ordered_vars <- c("wt", "cyl", "disp", "hp", "gear")
mod <- "mpg ~ wt"

by_trans2 <- mtcars %>%
    group_by(am) %>%                        # group data by transmission
    do(tidy(lm(mod, data = .))) %>%         # run model on each group
    rename(submodel = am) %>%               # make submodel variable
    mutate(model = "Model 1") %>%           # make model variable
    ungroup()

for (i in 2:5) {
    mod <- paste(mod, "+", ordered_vars[i])
    by_trans2 <- rbind(by_trans2, mtcars %>% 
                           group_by(am) %>%
                           do(tidy(lm(mod, data = .))) %>%
                           rename(submodel = am) %>%
                           mutate(model = paste("Model", i)) %>% 
                           ungroup())
}

# Relabel predictors (they will appear as facet labels)
by_trans2 <- by_trans2 %>%
    select(-submodel, everything(), submodel) %>% 
    relabel_predictors(c("(Intercept)" = "Intercept",
                         wt = "Weight",
                         cyl = "Cylinders",
                         disp = "Displacement",
                         hp = "Horsepower",
                         gear = "Gears"))

by_trans2

small_multiple(by_trans2) +
    theme_bw() + 
    ylab("Coefficient Estimate") +
    geom_hline(yintercept = 0, colour = "grey60", linetype = 2) +
    theme(axis.text.x  = element_text(angle = 45, hjust = 1),
          legend.position = c(0.02, 0.008), 
          legend.justification=c(0, 0),
          legend.title = element_text(size=8),
          legend.background = element_rect(color="gray90"),
          legend.spacing = unit(-4, "pt"),
          legend.key.size = unit(10, "pt")) +
    scale_colour_hue(name = "Transmission",
                     breaks = c(0, 1),
                     labels = c("Automatic", "Manual")) +
    ggtitle("Predicting Gas Mileage\nby Transmission Type")
```

## Conclusion

The `dotwhisker` package provides a flexible and convenient way to visualize regression results and to compare them across models. This vignette offers an overview of its use and features. We encourage users to consult the help files for more details. 

The development of the package is ongoing.  Please contact us with any questions, bug reports, and comments.

## Affiliation

Frederick Solt

Department of Political Science,

University of Iowa, 

324 Schaeffer Hall,

20 E Washington St, Iowa City, IA, 52242

Email: <frederick-solt@uiowa.edu>

Website: <https://fsolt.org>

<br></br>

Yue Hu

Department of Political Science,

Tsinghua University, 

Mingzhai 414, 

Zhongguacun Avenue, Haidian, Beijing 100084

Email: <yuehu@tsinghua.edu.cn>

Website: <https://sammo3182.github.io>

## References

